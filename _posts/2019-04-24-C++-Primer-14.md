---
layout: post
title: "C++ Primer 读书笔记 第14章 运算符重载与类型转换"
subtitle: 'C++ Primer Study Note For Operator Overloading And Type Conversion'
author: "Dongyuan"
header-style: text
tags:
  - C++ Primer
  - 读书笔记

---
## 基本概念
重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。

当一个重载的运算符时**成员函数**时，this绑定到左侧运算对象。成员运算符函数的显式参数数量比运算对象的数量少一个。

**对一个运算符来说，它或者是类的成员，或者至少含有一个类类型的参数。**

我们只能重载已有的运算符，而无权发明新的运算符号。对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。

### 直接调用一个重载的运算符
通用情况下，我们将运算符作用于类型正确的实参，从而以这种间接方式“调用”重载的运算符函数。然而，我们也能像调用普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参：
```c
// 一个非成员运算符函数的等价调用
data1 + data2 // 普通的表达式
operator + (data1, data2) // 等价的函数调用
```
我们像调用其他成员函数一样显式地调用成员运算符函数。首先指定运算符函数的对象（或指针）的名字，然后使用点运算符（或箭头运算符）访问希望调用的函数：
```c
data1 += data2 // 基于“调用”的表达式
data1.operator += (data2) // 对成员运算符函数的等价调用
```

### 某些运算符不应该重载
某些运算符指定了运算对象的求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是，逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。除此之外，&&和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。

还有一个原因使得我们一般不重载逗号运算符和取地址符：C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应。

通常情况下，不应该重载逗号、取地址、逻辑与、逻辑或运算符。

### 重载运算符需要与内置类型保持一致

### 赋值和复合赋值运算符
赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。重载的赋值运算符应该继承而非违背其内置版本的含义。

如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符

### 选择作为成员或者非成员
下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：

1. 赋值（=）、下标（[]）、调用（()）和成员访问箭头（->）运算符必须还是成员。
2. 复合赋值运算符一般来说应该是成员，但并非必须。
3. 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。
4. 具有对称性的运算符可能转换任一端的运算对象，例如算术、相等性、关系和位运算符等，通常应该是普通的非成员函数。

当把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。

当把运算符定义成普通的非成员函数时，唯一的要求是是至少有一个运算对象是类类型，并且两个运算对象都能精确无误地转换

## 输入和输出运算符
### 重载输出运算符<<
通常情况下，输出运算符的第一个形参是非常量ostream对象的引用。之所以ostream是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个ostream对象。

第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参是常量是因为通常情况打印对象不会改变对象的内容。

为了与其他输出运算符保持一致，operator<<一般要返回它的ostream形参

#### 输入输出运算符必须是非成员函数
与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数，因为我们无法给标准的类添加任何成员。

IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。

### 重载输入运算符>>
通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的非常量对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。

输入运算符必须处理输入可能失败的情况，而输出运算符不需要。

#### 输入时的错误
当流含有错误类型的数据时读取操作可能失败。
当读取到达文件末尾或者遇到输入流的其他错误时也会失败

可以在输入结束之后，使用之前进行输入是否成功的检查。

## 算术和关系运算符
通常情况下，我们把算术运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。

算术运算通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该变量的副本作为其结果。如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方法是使用复合赋值运算符来定义算术运算符。
```c
SalesData &SalesData::operator+=(const SalesData &rhs)
{
    m_unitssold += rhs.m_unitssold;
    m_revenue += rhs.m_revenue;
    return *this;
}

SalesData operator+(const SalesData &lhs, const SalesData &rhs)
{
    SalesData sum = lhs;
    sum += rhs;
    return sum;
}
```

### 相等运算符
通常情况下，C++中的类通过相等运算符来检验两个对象是否相等。也就是说，它们会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等。

### 关系运算符
定义了相等运算符的类也常常（但不总是）包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义operator<会比较有用。

通常情况下关系运算符应该：定义顺序关系，令其与关联容器中对关键字的要求一致。如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致。特别是，如果两个对象是!=的话，那么一个对象应该<另一个。

满足上面的条件再决定重载关系运算符。

## 赋值运算符
我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。赋值运算符返回其左侧运算对象的引用。

### 复合赋值运算符
复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括赋值在内的所有赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要返回其左侧运算对象的引用。
