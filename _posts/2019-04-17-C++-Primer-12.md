---
layout: post
title: "C++ Primer 读书笔记 第12章 动态内存"
subtitle: 'C++ Primer Study Note For Dynamic Memory'
author: "Dongyuan"
header-style: text
tags:
  - C++ Primer
  - 读书笔记
---

### shared_ptr类
最安全的分配和使用动态内存的方法是调用 make_shared 函数。
```C
auto p6 = make_shared<vector<string>>();
```

### shared_ptr的拷贝和赋值
其在Effictive C++ 中被称为引用计数智能指针，每个shared_ptr都有一个关联的计数器。在拷贝时，计数器加1，在赋值时，左边的智能指正计数减1，右边的智能指针计数加1。
```C
auto q(p);
auto r = make_shared<int>(42);
r = q;    //递减r原来指向的对象的引用计数，递增q指向的对象的引用计数
```

### shared_ptr 类通过析构函数自动销毁管理的对象'
在指向的对象引用计数为0后，还会自动释放指向的对象。
如果将** shared_ptr 存放于容器中**，而后不再需要全部的元素，只是用其中一部分，要记得erase删除不再需要的那些元素。

### 使用shared_ptr 在多个对象间共享数据
定义一个shared_ptr 类型的数据成员，则该类的默认版本的拷贝、赋值、销毁成员，作用于shared_ptr类型的数据成员时，会使用引用计数的特性达到对象间共享数据的目的。

### 使用new和delete直接管理内存
动态分配的const对象，用new分配const对象是合法的。
```C
cons tint *p = new cons int(1024);//返回的是指向const的指针
```

内存耗尽，自由空间被耗尽，new表达式就会失败，抛出bad_alloc异常。可以使用 nothrow阻止其抛出异常。bad_alloc、nothrow都被定义在头文件new中。
```C
int *p = new (nothrow) int;
```

指针值和delete，delete的指针必须指向动态分配的对象。使用delete释放一个空指针总是没有错误的。通常情况下，编译器不能分辨一个指针指向的是静态的还是动态分配的对象。类似的，编译器也不能分辨一个指针所指的内存是否已经被释放。

### 动态内存管理的常见错误
1.	忘记delete 内存。会导致内存泄漏问题，这种内存永远不可能被归还给自由空间。
2.	使用已经释放的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。
3.	同一块内存释放两次。两个指针指向同一个对象，delete这两个指针。
4.	Deletd之后重置指针的置，也只是提供了有限的保护。Delete内存之后，重置指针的方法只对这个指针有效，对其他指向该（已释放的）内存区域的指针是没有作用的。
