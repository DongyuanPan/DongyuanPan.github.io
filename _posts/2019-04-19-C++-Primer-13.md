---
layout: post
title: "C++ Primer 读书笔记 第13章 拷贝控制"
subtitle: 'C++ Primer Study Note For Copy Control'
author: "Dongyuan"
header-style: text
tags:
  - C++ Primer
  - 读书笔记

---

拷贝控制操作包含类的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算析构函数。

---

## 拷贝构造函数
一个构造函数的第一个参数是自身类型的引用，且任何额外的参数都有默认值。
```c
class F0oo{
  Foo();              //构造函数
  Foo(const Foo&)     //拷贝构造函数
}
```
第一个参数必须是引用类型，可以定义一个接受非const 引用的拷贝构造函数，但是此参数总是一个const引用。拷贝构造函数在几种情况下都会被隐式的使用，所以拷贝构造函数通常不应该在是explicit的。

### 合成拷贝构造函数
即使自己定义了一个构造函数，编译器也会为我们合成一个拷贝构造函数。编译器从给定对象中一次将每个非static成员花拷贝到正在创建的对象中。每个成员的类型决定了它如何拷贝，对类类型的成员，会使用期拷贝构造函数来拷贝，内置类型的成员直接拷贝。

### 拷贝初始化
直接初始化和拷贝初始化的差异：直接初始化，是通过函数匹配来选择与提供参数的最匹配的构造函数。拷贝初始化，是将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

拷贝初始化通过拷贝构造函数或者移动构造函数完成的。拷贝初始化不仅发生在我们用=定义变量的时候会发生，在下面情况也会发生：
1. 讲一个对象作为实参传递给一个非引用的形参。
2. 从一个返回类型为非引用类型的函数返回一个对象。
3. 从花括号列表初始化一个数组中的元素或者一个聚合类的成员。

某些类型会对他们分配的对象使用拷贝初始化，例如初始化标准容器或者调用insert或者push成员。容器会对其元素进行拷贝初始化，与之相对的，用emplace成员创建的元素都直接进行值初始化。

### 参数和返回值
函数调用过程中，非引用类型的参数要进行拷贝初始化。非引用的返回类型，返回值会被用来初始化调用方的结果。

拷贝构造函数被用来初始化非引用类类型参数。所以拷贝构造函数自己的参数必须是引用，不然调用拷贝构造函数，传递参数又需要调用拷贝构造函数，造成循环调用。

## 拷贝赋值运算符
赋值运算符通常应该返回一个指向其左侧运算对象的引用。

## 析构函数
析构函数释放对象使用的资源，并销毁对象的而非static数据成员。由于析构函数不接受参数，因此它不能重载。对一个给定的类，只会有唯一一个析构函数。

在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时发生什么，完全依赖于成员的类型，销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构，因此销毁内置类型成员什么也不干。

隐式销毁一个内置指针类型的成员不会delete它所指向的对象。但是智能指针会，因为智能指针是类类型，具有析构函数。

### 什么时候调用析构
无论何时一个对象被销毁的时候。当指向一个对象的引用或者指针离开作用域时，析构函数不会执行。

析构函数体本省不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。

## 三五法则
需要析构函数函数的类也需要拷贝和赋值操作：如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。例如，自定义析构函数，释放指针所指向的对象的情况P448。

需要拷贝操作的类也需要赋值操作，反之亦然。

## 使用 =default
将拷贝控制成员定义为=default 来显示的要求比编译器生成合成的版本。在类内使用时，合成的函数将隐式的声明为内联函数。不希望内联，则在类外定义使用=default。

只可以对具有合成版本的成员函数使用，即，默认构造函数和拷贝控制成员。

## 阻止拷贝
新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数。表明，虽然定义了它，但是不能以任何方式使用它们。在函数列表后面加上=delete定义删除的函数。

与=default不同，=delete必须出现在函数第一次声明的时候。

### 析构函数不是能删除的成员
如果删除了析构函数，不能定义这种类型的变量或者成员，但是可以动态的分配这种对象。但是无法释放这些对象。

对于析构已经函数的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的指针。（不可以 delete 该指针）

### 合成的拷贝控制成员 可能是删除的

1. 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，那对应生成的合成成员函数将被定义为删除的。

2. 一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，因为如果不是删除的话，我们就会创建出无法被销毁的对象。

3. 对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数，因为引用和const都必须在创建的时候就初始化，所以编译器无法去赋值它们，就是说你在类成员定义的时候就必须去初始化它们，那你要默认构造函数干嘛，索性就不合成了。

  PS：如果有const，那在定义的时候就初始化了，你在默认构造函数里面再去赋值给const就是错的。对于引用，虽然我们可以把一个新值给这个引用，但我们改变的是引用绑定的那个对象，而不是引用本身，这个行为往往不是我们想要的。
