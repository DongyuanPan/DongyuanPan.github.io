---
layout: post
title: "C++ Primer 读书笔记 第13章 拷贝控制"
subtitle: 'C++ Primer Study Note For Copy Control'
author: "Dongyuan"
header-style: text
tags:
  - C++ Primer
  - 读书笔记

---

拷贝控制操作包含类的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算析构函数。

---

## 拷贝构造函数
一个构造函数的第一个参数是自身类型的引用，且任何额外的参数都有默认值。
```c
class F0oo{
  Foo();              //构造函数
  Foo(const Foo&)     //拷贝构造函数
}
```
第一个参数必须是引用类型，可以定义一个接受非const 引用的拷贝构造函数，但是此参数总是一个const引用。拷贝构造函数在几种情况下都会被隐式的使用，所以拷贝构造函数通常不应该在是explicit的。

### 合成拷贝构造函数
即使自己定义了一个构造函数，编译器也会为我们合成一个拷贝构造函数。编译器从给定对象中一次将每个非static成员花拷贝到正在创建的对象中。每个成员的类型决定了它如何拷贝，对类类型的成员，会使用期拷贝构造函数来拷贝，内置类型的成员直接拷贝。

### 拷贝初始化
直接初始化和拷贝初始化的差异：直接初始化，是通过函数匹配来选择与提供参数的最匹配的构造函数。拷贝初始化，是将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

拷贝初始化通过拷贝构造函数或者移动构造函数完成的。拷贝初始化不仅发生在我们用=定义变量的时候会发生，在下面情况也会发生：
1. 讲一个对象作为实参传递给一个非引用的形参。
2. 从一个返回类型为非引用类型的函数返回一个对象。
3. 从花括号列表初始化一个数组中的元素或者一个聚合类的成员。

某些类型会对他们分配的对象使用拷贝初始化，例如初始化标准容器或者调用insert或者push成员。容器会对其元素进行拷贝初始化，与之相对的，用emplace成员创建的元素都直接进行值初始化。

### 参数和返回值
函数调用过程中，非引用类型的参数要进行拷贝初始化。非引用的返回类型，返回值会被用来初始化调用方的结果。

拷贝构造函数被用来初始化非引用类类型参数。所以拷贝构造函数自己的参数必须是引用，不然调用拷贝构造函数，传递参数又需要调用拷贝构造函数，造成循环调用。

## 拷贝赋值运算符
赋值运算符通常应该返回一个指向其左侧运算对象的引用。

## 析构函数
析构函数释放对象使用的资源，并销毁对象的而非static数据成员。由于析构函数不接受参数，因此它不能重载。对一个给定的类，只会有唯一一个析构函数。

在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时发生什么，完全依赖于成员的类型，销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构，因此销毁内置类型成员什么也不干。

隐式销毁一个内置指针类型的成员不会delete它所指向的对象。但是智能指针会，因为智能指针是类类型，具有析构函数。

### 什么时候调用析构
无论何时一个对象被销毁的时候。当指向一个对象的引用或者指针离开作用域时，析构函数不会执行。

析构函数体本省不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。

## 三五法则
需要析构函数函数的类也需要拷贝和赋值操作：如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。例如，自定义析构函数，释放指针所指向的对象的情况P448。

需要拷贝操作的类也需要赋值操作，反之亦然。

## 使用 =default
将拷贝控制成员定义为=default 来显示的要求比编译器生成合成的版本。在类内使用时，合成的函数将隐式的声明为内联函数。不希望内联，则在类外定义使用=default。

只可以对具有合成版本的成员函数使用，即，默认构造函数和拷贝控制成员。

## 阻止拷贝
新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数。表明，虽然定义了它，但是不能以任何方式使用它们。在函数列表后面加上=delete定义删除的函数。

与=default不同，=delete必须出现在函数第一次声明的时候。

### 析构函数不是能删除的成员
如果删除了析构函数，不能定义这种类型的变量或者成员，但是可以动态的分配这种对象。但是无法释放这些对象。

对于析构已经函数的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的指针。（不可以 delete 该指针）

### 合成的拷贝控制成员 可能是删除的

1. 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，那对应生成的合成成员函数将被定义为删除的。

2. 一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，因为如果不是删除的话，我们就会创建出无法被销毁的对象。

3. 对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数，因为引用和const都必须在创建的时候就初始化，所以编译器无法去赋值它们，就是说你在类成员定义的时候就必须去初始化它们，那你要默认构造函数干嘛，索性就不合成了。

  PS：如果有const，那在定义的时候就初始化了，你在默认构造函数里面再去赋值给const就是错的。对于引用，虽然我们可以把一个新值给这个引用，但我们改变的是引用绑定的那个对象，而不是引用本身，这个行为往往不是我们想要的。

### private 拷贝控制
新标准之前，通过声明（但不定义）private的拷贝构造函数，可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。

希望阻止拷贝的类型应该使用=delete来定义他们自己的来拷贝构造函数和拷贝赋值运算符，而不是将他们声明为private。

## 拷贝控制和资源管理
通过定义拷贝控制成员：使类的行为看起来像一个值，或像一个指针。行为像值的类：对于类管理的资源，每个对象都拥有一份自己的拷贝。行为像指针的类：多个对象共同管理相同的资源。

类直接拷贝内置类型（不包括指针）成员，这些成员本省就是值，所以应当让他们的行为像值一样。如何拷贝指针成员决定了类具有类值行为还是类指针行为。

### 类行为像值的类
操作的行为是对指针指向的对象，而不是指针自己。

类值拷贝赋值运算符，需要考虑自己赋值给自己的情况。赋值运算符组合了析构函数和拷贝构造函数的工作。先将右侧运算对象拷贝到一个局部临时对象中，当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。销毁运算对象左侧的资源后，将数据从临时对象拷贝到左侧运算对象。

### 定义行为像指针的类
令一个类展现类似指针的行为的最好方法是使用 shared_ptr智能指针。

如果想直接管理资源，可以使用 **引用计数** 的方式。**引用计数** 存放的位置不能是数据成员，应当存放在动态内存中。当创建一个对象的时候，我们分配一个新的计数器。当拷贝或者赋值对象的时候，我们拷贝指向计数器的指针。这样副本和原对象都会孩子想相同的计数器。

HasPtr类的例子P456

## 交换操作

如果一个类自定义了swap操作，那么算法将使用类自定义版本的swap，否则算法将使用标准库定义的swap。

交换两个对象，一般需要进行一次拷贝和两次赋值操作。但是这种交换是不对数据的对象的，当交换string时，会造成不必要别的内存分配。我们更希望swap交换指针，而不是分配string的新副本。

与拷贝控制成员不同，swap并不是必要的。但是对于分配了资源的类，定义swap可能是一种很重要的优化手段。

### swap函数应该调用swap，而不是std::swap并不是必要的

```c
void swap(Foo &lhs, FOO &rhs){
  //错误，使用了标准库版本的swap，而不是类自己定义的
  std::swap(lhs.s, rhs.s);
}

void swap(Foo &lhs, FOO &rhs){
  //正确版本
  using std::swap;
  swap(lhs.s, rhs.s);
}
```

### 在赋值运算符中使用swap
定义了swap的类通常使用swap来定义他们的赋值运算符。这些运算符使用了一种，名为拷贝并交换的技术。这种技术，将左侧运算对象与右侧运算对象的一个副本进行交换。
```c
void swap(A& rhs) {
    using std::swap;
    swap(this->a,rhs.a);
    swap(this->b,rhs.b);
}

//形参不是引用，因此这里调用 = 运算符将发生 拷贝
A& operator=(A rhs) {
    swap(rhs);
    return * this;
}

```

使用拷贝和交换的赋值运算符自动就是一场安全的，且呢更正确处理自赋值。
