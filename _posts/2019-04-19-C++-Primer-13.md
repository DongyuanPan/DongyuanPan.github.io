---
layout: post
title: "C++ Primer 读书笔记 第13章 拷贝控制"
subtitle: 'C++ Primer Study Note For Copy Control'
author: "Dongyuan"
header-style: text
tags:
  - C++ Primer
  - 读书笔记

---

拷贝控制操作包含类的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算析构函数。

---

## 拷贝构造函数
一个构造函数的第一个参数是自身类型的引用，且任何额外的参数都有默认值。
```c
class F0oo{
  Foo();              //构造函数
  Foo(const Foo&)     //拷贝构造函数
}
```
第一个参数必须是引用类型，可以定义一个接受非const 引用的拷贝构造函数，但是此参数总是一个const引用。拷贝构造函数在几种情况下都会被隐式的使用，所以拷贝构造函数通常不应该在是explicit的。

### 合成拷贝构造函数
即使自己定义了一个构造函数，编译器也会为我们合成一个拷贝构造函数。编译器从给定对象中一次将每个非static成员花拷贝到正在创建的对象中。每个成员的类型决定了它如何拷贝，对类类型的成员，会使用期拷贝构造函数来拷贝，内置类型的成员直接拷贝。

### 拷贝初始化
直接初始化和拷贝初始化的差异：直接初始化，是通过函数匹配来选择与提供参数的最匹配的构造函数。拷贝初始化，是将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

拷贝初始化通过拷贝构造函数或者移动构造函数完成的。拷贝初始化不仅发生在我们用=定义变量的时候会发生，在下面情况也会发生：
1. 讲一个对象作为实参传递给一个非引用的形参。
2. 从一个返回类型为非引用类型的函数返回一个对象。
3. 从花括号列表初始化一个数组中的元素或者一个聚合类的成员。

某些类型会对他们分配的对象使用拷贝初始化，例如初始化标准容器或者调用insert或者push成员。容器会对其元素进行拷贝初始化，与之相对的，用emplace成员创建的元素都直接进行值初始化。

### 参数和返回值
函数调用过程中，非引用类型的参数要进行拷贝初始化。非引用的返回类型，返回值会被用来初始化调用方的结果。

拷贝构造函数被用来初始化非引用类类型参数。所以拷贝构造函数自己的参数必须是引用，不然调用拷贝构造函数，传递参数又需要调用拷贝构造函数，造成循环调用。

## 拷贝赋值运算符
赋值运算符通常应该返回一个指向其左侧运算对象的引用。

## 析构函数
析构函数释放对象使用的资源，并销毁对象的而非static数据成员。由于析构函数不接受参数，因此它不能重载。对一个给定的类，只会有唯一一个析构函数。

在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时发生什么，完全依赖于成员的类型，销毁类类型的成员需要执行成员自己的析构函数，内置类型没有析构，因此销毁内置类型成员什么也不干。

隐式销毁一个内置指针类型的成员不会delete它所指向的对象。但是智能指针会，因为智能指针是类类型，具有析构函数。

### 什么时候调用析构
无论何时一个对象被销毁的时候。当指向一个对象的引用或者指针离开作用域时，析构函数不会执行。

析构函数体本省不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。

## 三五法则
需要析构函数函数的类也需要拷贝和赋值操作：如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。例如，自定义析构函数，释放指针所指向的对象的情况P448。

需要拷贝操作的类也需要赋值操作，反之亦然。

## 使用 =default
将拷贝控制成员定义为=default 来显示的要求比编译器生成合成的版本。在类内使用时，合成的函数将隐式的声明为内联函数。不希望内联，则在类外定义使用=default。

只可以对具有合成版本的成员函数使用，即，默认构造函数和拷贝控制成员。

## 阻止拷贝
新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数。表明，虽然定义了它，但是不能以任何方式使用它们。在函数列表后面加上=delete定义删除的函数。

与=default不同，=delete必须出现在函数第一次声明的时候。

### 析构函数不是能删除的成员
如果删除了析构函数，不能定义这种类型的变量或者成员，但是可以动态的分配这种对象。但是无法释放这些对象。

对于析构已经函数的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的指针。（不可以 delete 该指针）

### 合成的拷贝控制成员 可能是删除的

1. 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，那对应生成的合成成员函数将被定义为删除的。

2. 一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，因为如果不是删除的话，我们就会创建出无法被销毁的对象。

3. 对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数，因为引用和const都必须在创建的时候就初始化，所以编译器无法去赋值它们，就是说你在类成员定义的时候就必须去初始化它们，那你要默认构造函数干嘛，索性就不合成了。

  PS：如果有const，那在定义的时候就初始化了，你在默认构造函数里面再去赋值给const就是错的。对于引用，虽然我们可以把一个新值给这个引用，但我们改变的是引用绑定的那个对象，而不是引用本身，这个行为往往不是我们想要的。

### private 拷贝控制
新标准之前，通过声明（但不定义）private的拷贝构造函数，可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。

希望阻止拷贝的类型应该使用=delete来定义他们自己的来拷贝构造函数和拷贝赋值运算符，而不是将他们声明为private。

## 拷贝控制和资源管理
通过定义拷贝控制成员：使类的行为看起来像一个值，或像一个指针。行为像值的类：对于类管理的资源，每个对象都拥有一份自己的拷贝。行为像指针的类：多个对象共同管理相同的资源。

类直接拷贝内置类型（不包括指针）成员，这些成员本省就是值，所以应当让他们的行为像值一样。如何拷贝指针成员决定了类具有类值行为还是类指针行为。

### 类行为像值的类
操作的行为是对指针指向的对象，而不是指针自己。

类值拷贝赋值运算符，需要考虑自己赋值给自己的情况。赋值运算符组合了析构函数和拷贝构造函数的工作。先将右侧运算对象拷贝到一个局部临时对象中，当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。销毁运算对象左侧的资源后，将数据从临时对象拷贝到左侧运算对象。

### 定义行为像指针的类
令一个类展现类似指针的行为的最好方法是使用 shared_ptr智能指针。

如果想直接管理资源，可以使用 **引用计数** 的方式。**引用计数** 存放的位置不能是数据成员，应当存放在动态内存中。当创建一个对象的时候，我们分配一个新的计数器。当拷贝或者赋值对象的时候，我们拷贝指向计数器的指针。这样副本和原对象都会孩子想相同的计数器。

HasPtr类的例子P456

## 交换操作

如果一个类自定义了swap操作，那么算法将使用类自定义版本的swap，否则算法将使用标准库定义的swap。

交换两个对象，一般需要进行一次拷贝和两次赋值操作。但是这种交换是不对数据的对象的，当交换string时，会造成不必要别的内存分配。我们更希望swap交换指针，而不是分配string的新副本。

与拷贝控制成员不同，swap并不是必要的。但是对于分配了资源的类，定义swap可能是一种很重要的优化手段。

### swap函数应该调用swap，而不是std::swap并不是必要的

```c
void swap(Foo &lhs, FOO &rhs){
  //错误，使用了标准库版本的swap，而不是类自己定义的
  std::swap(lhs.s, rhs.s);
}

void swap(Foo &lhs, FOO &rhs){
  //正确版本
  using std::swap;
  swap(lhs.s, rhs.s);
}
```

### 在赋值运算符中使用swap
定义了swap的类通常使用swap来定义他们的赋值运算符。这些运算符使用了一种，名为拷贝并交换的技术。这种技术，将左侧运算对象与右侧运算对象的一个副本进行交换。
```c
void swap(A& rhs) {
    using std::swap;
    swap(this->a,rhs.a);
    swap(this->b,rhs.b);
}

//形参不是引用，因此这里调用 = 运算符将发生 拷贝
A& operator=(A rhs) {
    swap(rhs);
    return * this;
}

```

使用拷贝和交换的赋值运算符自动就是一场安全的，且呢更正确处理自赋值。

### 动态内存管理类
实现简单的vector，使用construct来构造元素。STL源码剖析中，第二章空间配置器。

##对象移动
移动而非拷贝对象会大幅提升性能。标准容器库、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_prt类可以移动但是不能拷贝。

### 右值引用
必须绑定到右值的引用，通过&&而不是&来获得右值引用。它只能绑定到一个将要销毁的对象。

返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都返回左值的表达式。左值引用可以绑定到这类表达式上。

返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。不可以将左值引用绑定到这类表达式上，但可以将一个const的左值引用或者以一个右值引用绑定到这类表达式上。

#### 左值持久，右值短暂
左值有持久的状态，右值要么是字面值常量，要么是在表达式求值过程中创建的临时对象。
右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值的对象“窃取”状态。

#### 变量是左值
因此，不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。

#### 标准库move函数
虽然不可以将一个右值引用直接绑定到一个左值上，但可以显示的将一个左值转换为对应的右值引用类型。通过调用move 的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。

```c
int &&rr3 = std::move(rr1);
```

可以销毁一个移动之后的源对象，也可以赋予新值，但是不可以使用移动后源对象的值。

### 移动构造函数和移动赋值运算符
移动构造函数的第一个参数该类型的一个右值引用，且任何额外的参数都必须有默认实参。
```c
strVec::Strvec(strVec &&s) noexcept //移动操作不应抛出异常
  :element(s.element), first_free(s.first_free), cap(s.cap)
  {
    s.element = s.first_free = s.cap = nullptr;
  }
```

#### 移动操作、标准库容器和异常
如果希望类似vector重新分配内存这种情况下对我们自定义类型的对象使用移动而不是拷贝，就必须显示地告诉标准库我们的移动构造函数可以安全使用。

不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。

#### 移动赋值运算符
也要考虑自赋值的情况，不过可以直接检测自赋值。

#### 移后源对象必须可以析构
移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其值进行任何假设。

#### 合成的移动操作
只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或者移动赋值运算符。编译器可以移动内置类型的成员，对于成员是类类型，该类有对应当的移动操作，编译器也能移动该成员。

和拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式地要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。移动操作定义为删除的函数的原则：

1. 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。
2. 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。
3. 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。
4. 类似拷贝赋值运算符，如果有类成员是const的或引用，则类的移动赋值运算符被定义为删除的。

**定义了一个移动构造函数或移动赋值运算符的类必须定义自己的拷贝操作。否则，这些成员默认地被定义为删除的**

#### 移动右值，拷贝左值
如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值的情况类似。

#### 如果没有移动构造函数，右值也被拷贝
如果一个类有一个拷贝构造函数但未定义移动构造函数，会发生什么呢？在此情况下，编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数但不会有移动构造函数。如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用move来移动它们时也是如此，其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动移动赋值运算符的情况类似。

#### 拷贝并交换赋值元素安抚和移动操作
```c
 Demo &operator=(Demo rhs)
 {
     std::cout << "=" << std::endl;
     swap(*this, rhs);
     return * this;
 }

 ```

 观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。

更新的三五法则： 一般来说，一个类定义了任何一个拷贝操作，它就应该定义所有的五个操作。

#### 移动迭代器
先标准库中定义了一种移动迭代器适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，**移动迭代器的解引用运算符生成一个右值引用。**

调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。

**由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。**

```c
void StrVec::reallocate()
{
    /*
    // 不使用移动迭代器的版本
    auto newcapacity = size() ? 2 * size() : 1;
    auto newdata = alloc.allocate(newcapacity);
    auto dest = newdata;
    auto elem = elements;
    for (std::size_t i = 0; i != size(); ++i)
        alloc.construct(dest++, std::move(*elem++));
    free();
    elements = newdata;
    first_free = dest;
    cap = elements + newcapacity;
    */
    // 使用移动迭代器的版本
    auto newcapacity = size() ? 2 * size() : 1;
    auto first = alloc.allocate(newcapacity);
    auto last = std::uninitialized_copy(std::make_move_iterator(begin()), std::make_move_iterator(end()), first);
    free(); // 释放旧空间
    elements = first;
    first_free = last;
    cap = elements + newcapacity;
}

```
### 右值引用和成员函数

这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式——一个版本接受一个指向const的左值引用，第二个版本接受一个指向非const的右值引用。

一般来说，我们不需要为函数操作定义接受一个const X&&或是一个普通的X&参数的版本。当我们希望实参“窃取”数据时，通常传递一个右值引用。为了达到这一目的，实参不能是const的。类似的，从一个对象进行拷贝的操作不应该改变该对象。因此，通常不需要定义一个接受普通的X&参数版本。

NOTE： 区分移动和拷贝的重载函数通常有一个版本接受一个 const T&， 而另一个接受 T &&。

```c
void StrVec::push_back(const std::string &s)
{
    std::cout << "push_back--copy" << std::endl;
    check_n_alloc();
    alloc.construct(first_free++, s); // 在first_free指向的元素中构造s的一个副本
}

void StrVec::push_back(std::string &&s)
{
    std::cout << "push_back--move" << std::endl;
    check_n_alloc();
    alloc.construct(first_free++, std::move(s));
}
```
#### 右值和左值引用成员函数
有时候，我们希望强制左侧运算对象（即this执行的对象）是一个左值。

我们希望指出this的左值/右值属性的方式与定义const成员函数相同，即，在参数列表后放置一个引用限定符。引用限定符可以是&或&&，分别指出this可以指向一个左值或右值。类似const限定符，引用限定符只能用于非static成员函数，且必须同时出现在函数的声明和定义中。
```c
class Foo {
public:
    Foo &operator=(const Foo &)&; // 只能向可修改的左值赋值
};
Foo &Foo::operator=(const Foo &rhs)&
{
    //指向将rhs赋予本对象的操作
    return *this;
}
```

一个函数可以同时用const和引用限定。在此情况下，引用限定符必须跟随在const限定符之后。

#### 重载和引用函数
**就像一个成员函数可以根据是否有const来区分其重载版本一样，引用限定符也可以区分重载版本。**

当我们定义const成员函数时，可以定义两个版本，唯一的差别是一个版本有const限定而另一个没有。引用限定的函数则不一样，如果一个成员函数有引用限定符，则具有**相同参数列表的所有版本**都必须有引用限定符。
```c
class Foo {
public:
    Foo sorted() && ; // 可用于改变的右值
    Foo sorted() const &; // 可用于任何类型的Foo
private:
    std::vector<int> data;
};
// 本对象为右值，因此可以原址改变
Foo Foo::sorted() &&
{
    sort(data.begin(), data.end());
    return *this;
}
// 本对象是const或是一个左值，哪种情况我们都不能对其进行原址排序
Foo Foo::sorted()const&
{
    Foo ret(*this);
    sort(ret.data.begin(), ret.data.end()); // 排序副本
    return ret; // 返回副本
}
```
